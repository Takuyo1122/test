<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Open When - 手紙作成＆閲覧（URL生成）</title>
  <meta name="description" content="サーバー不要。作成した手紙はURLに暗号化して埋め込み、共有できます。スマホ向けUI。" />
  <style>
    :root{
      --bg:#0b0f14; --card:#121821; --accent:#4da3ff; --muted:#8aa3bf; --text:#eaf2ff;
      --ok:#2ecc71; --warn:#ffb020; --err:#ff5c5c;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic",sans-serif;background:linear-gradient(180deg,#0b0f14,#10161f 40%,#0b0f14);color:var(--text);}
    .wrap{max-width:720px;margin:0 auto;padding:clamp(12px,4vw,28px);}
    .card{background:var(--card);border:1px solid #1b2431;border-radius:20px;padding:clamp(14px,3.5vw,22px);box-shadow:0 10px 30px rgba(0,0,0,.3)}
    h1{font-size:clamp(22px,6vw,30px);margin:0 0 8px;}
    p.lead{color:var(--muted);margin:0 0 18px;font-size:clamp(13px,3.6vw,15px)}
    label{display:block;margin:14px 0 6px;color:#c8d7ee;font-size:14px}
    input, textarea{width:100%;background:#0f141c;color:var(--text);border:1px solid #1f2a39;border-radius:14px;padding:14px;font-size:16px;outline:none}
    textarea{min-height:160px;resize:vertical}
    .row{display:grid;gap:12px;grid-template-columns:1fr 1fr}
    .btn{appearance:none;display:inline-flex;align-items:center;justify-content:center;gap:8px;border:none;border-radius:16px;padding:14px 16px;font-weight:600;font-size:16px;cursor:pointer;transition:transform .05s ease,filter .15s ease;}
    .btn:active{transform:translateY(1px)}
    .primary{background:var(--accent);color:#041020}
    .ghost{background:transparent;border:1px solid #263243;color:#cfe1ff}
    .muted{color:var(--muted);font-size:13px}
    .hidden{display:none}
    .copybox{display:flex;gap:8px;background:#0f141c;border:1px solid #1f2a39;border-radius:14px;padding:8px}
    .copybox input{border:none;background:transparent;padding:10px}
    .pill{display:inline-block;background:#0f141c;border:1px solid #223047;border-radius:999px;padding:6px 10px;font-size:12px;color:#cfe1ff}
    .lock{color:var(--warn)}
    .center{text-align:center}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
    .footer{opacity:.7;margin-top:18px;font-size:12px}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card" id="create">
      <h1>Open When ✉️</h1>
      <p class="lead">手紙を作ると、<strong>その手紙専用URL</strong>が自動で作成されます。サーバー不要／スマホ向け。</p>

      <label>タイトル（例：落ち込んだときに開けて）</label>
      <input id="title" placeholder="例：つらい日が続いたら読んで…" />

      <label>本文</label>
      <textarea id="body" placeholder="ここに手紙を書いてね"></textarea>

      <div class="row">
        <div>
          <label>開封を許可する日時（任意）</label>
          <input id="unlockAt" type="datetime-local" />
        </div>
        <div>
          <label>パスワード（任意・共有相手のみ） <span class="pill lock">AES‑GCM暗号化</span></label>
          <input id="password" type="password" placeholder="設定しない場合は空欄でOK" />
        </div>
      </div>

      <div style="margin-top:16px;display:flex;gap:10px;flex-wrap:wrap">
        <button class="btn primary" id="make">URLを作成</button>
        <button class="btn ghost" id="demo">サンプルで試す</button>
      </div>

      <div id="result" class="hidden" style="margin-top:18px">
        <p class="muted">このURLを相手に送ってください：</p>
        <div class="copybox">
          <input id="shareUrl" readonly>
          <button class="btn primary" id="copy">コピー</button>
        </div>
        <p class="muted mono" id="urlSize"></p>
      </div>

      <div class="footer">※ URLの<b>ハッシュ部分</b>（#以降）に暗号化・圧縮データを埋め込むため、
        サーバーに内容は送信されません。長文の場合はURLが長くなります。
      </div>
    </div>

    <div class="card hidden" id="view">
      <div id="gate" class="hidden">
        <h1 id="vtitle">Open When…</h1>
        <p id="lockinfo" class="muted"></p>
        <div id="pwWrap" class="hidden">
          <label>パスワード</label>
          <input id="viewPw" type="password" placeholder="送られてきたパスワードを入力" />
          <div style="margin-top:12px"><button class="btn primary" id="open">開封する</button></div>
        </div>
      </div>
      <div id="letter" class="hidden">
        <h1 id="ltitle"></h1>
        <article id="lbody" style="white-space:pre-wrap;line-height:1.7"></article>
        <div class="footer">
          <span class="pill">クライアント復号</span>
          <span class="pill">#URL埋め込み</span>
          <button class="btn ghost" style="float:right" id="makeNew">新しく作る</button>
        </div>
      </div>
    </div>
  </div>

<script>
/* ----------------------------
  LZ-based 圧縮（LZStringの最小必要関数のみ）
  出典: pieroxy/lz-string を参考に一部簡略（ライセンスMIT）。
  ここでは Base64 文字列で入出力する helper に限定。
-----------------------------*/
const LZ64 = (function(){
  const f = String.fromCharCode;
  const keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  function getBaseValue(alphabet, character){
    if (!LZ64.baseReverseDic) LZ64.baseReverseDic = {};
    if (!LZ64.baseReverseDic[alphabet]){
      LZ64.baseReverseDic[alphabet] = {};
      for (let i=0; i<alphabet.length; i++) LZ64.baseReverseDic[alphabet][alphabet.charAt(i)] = i;
    }
    return LZ64.baseReverseDic[alphabet][character];
  }
  function compressToBase64 (input){
    if (input == null) return "";
    const res = _compress(input, 6, a=>keyStrBase64.charAt(a));
    switch (res.length % 4){case 0: return res; case 1: return res+"==="; case 2: return res+"=="; case 3: return res+"=";}
  }
  function decompressFromBase64 (input){
    if (input == null) return "";
    if (input === "") return null;
    return _decompress(input.length, 32, idx=>getBaseValue(keyStrBase64, input.charAt(idx)));
  }
  function _compress (uncompressed, bitsPerChar, getCharFromInt){
    if (uncompressed == null) return "";
    let i, value, context_dictionary = {}, context_dictionaryToCreate = {}, context_c = "", context_wc = "", context_w = "", context_enlargeIn = 2, context_dictSize = 3, context_numBits = 2, context_data=[], context_data_val=0, context_data_position=0;
    for (let ii=0; ii<uncompressed.length; ii+=1){
      context_c = uncompressed.charAt(ii);
      if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)){
        context_dictionary[context_c] = context_dictSize++;
        context_dictionaryToCreate[context_c] = true;
      }
      context_wc = context_w + context_c;
      if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)){
        context_w = context_wc;
      } else {
        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)){
          if (context_w.charCodeAt(0)<256){
            for (i=0;i<context_numBits;i++) {context_data_val = (context_data_val << 1); if(context_data_position==bitsPerChar-1){context_data_position=0; context_data.push(getCharFromInt(context_data_val)); context_data_val=0;} else context_data_position++;}
            value = context_w.charCodeAt(0);
            for (i=0;i<8;i++){context_data_val = (context_data_val << 1) | (value&1); if(context_data_position==bitsPerChar-1){context_data_position=0; context_data.push(getCharFromInt(context_data_val)); context_data_val=0;} else context_data_position++; value >>=1;}
          } else {
            value=1; for (i=0;i<16;i++){context_data_val=(context_data_val<<1)|value; if(context_data_position==bitsPerChar-1){context_data_position=0; context_data.push(getCharFromInt(context_data_val)); context_data_val=0;} else context_data_position++; value=0;}
            value=context_w.charCodeAt(0); for (i=0;i<16;i++){context_data_val=(context_data_val<<1)|(value&1); if(context_data_position==bitsPerChar-1){context_data_position=0; context_data.push(getCharFromInt(context_data_val)); context_data_val=0;} else context_data_position++; value >>=1;}
          }
          context_enlargeIn--; if (context_enlargeIn==0){context_enlargeIn=Math.pow(2, context_numBits); context_numBits++;}
          delete context_dictionaryToCreate[context_w];
        } else {
          value=context_dictionary[context_w]; for (i=0;i<context_numBits;i++){context_data_val=(context_data_val<<1)|(value&1); if(context_data_position==bitsPerChar-1){context_data_position=0; context_data.push(getCharFromInt(context_data_val)); context_data_val=0;} else context_data_position++; value >>=1;}
        }
        context_enlargeIn--; if (context_enlargeIn==0){context_enlargeIn=Math.pow(2, context_numBits); context_numBits++;}
        context_dictionary[context_wc]=context_dictSize++;
        context_w=String(context_c);
      }
    }
    if (context_w!==''){
      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)){
        if (context_w.charCodeAt(0)<256){
          for (i=0;i<context_numBits;i++){context_data_val=(context_data_val<<1); if(context_data_position==bitsPerChar-1){context_data_position=0; context_data.push(getCharFromInt(context_data_val)); context_data_val=0;} else context_data_position++;}
          value=context_w.charCodeAt(0); for (i=0;i<8;i++){context_data_val=(context_data_val<<1)|(value&1); if(context_data_position==bitsPerChar-1){context_data_position=0; context_data.push(getCharFromInt(context_data_val)); context_data_val=0;} else context_data_position++; value >>=1;}
        } else {
          value=1; for (i=0;i<16;i++){context_data_val=(context_data_val<<1)|value; if(context_data_position==bitsPerChar-1){context_data_position=0; context_data.push(getCharFromInt(context_data_val)); context_data_val=0;} else context_data_position++; value=0;}
          value=context_w.charCodeAt(0); for (i=0;i<16;i++){context_data_val=(context_data_val<<1)|(value&1); if(context_data_position==bitsPerChar-1){context_data_position=0; context_data.push(getCharFromInt(context_data_val)); context_data_val=0;} else context_data_position++; value >>=1;}
        }
        context_enlargeIn--; if (context_enlargeIn==0){context_enlargeIn=Math.pow(2, context_numBits); context_numBits++;}
        delete context_dictionaryToCreate[context_w];
      } else {
        value=context_dictionary[context_w]; for (i=0;i<context_numBits;i++){context_data_val=(context_data_val<<1)|(value&1); if(context_data_position==bitsPerChar-1){context_data_position=0; context_data.push(getCharFromInt(context_data_val)); context_data_val=0;} else context_data_position++; value >>=1;}
      }
      context_enlargeIn--; if (context_enlargeIn==0){context_enlargeIn=Math.pow(2, context_numBits); context_numBits++;}
    }
    value=2; for (i=0;i<context_numBits;i++){context_data_val=(context_data_val<<1)|(value&1); if(context_data_position==bitsPerChar-1){context_data_position=0; context_data.push(getCharFromInt(context_data_val)); context_data_val=0;} else context_data_position++; value >>=1;}
    while (true){context_data_val=(context_data_val<<1); if(context_data_position==bitsPerChar-1){context_data.push(getCharFromInt(context_data_val)); break;} else context_data_position++;}
    return context_data.join("");
  }
  function _decompress(length, resetValue, getNextValue){
    const dictionary = [0,1,2];
    let enlargeIn = 4, dictSize = 4, numBits = 3, entry = "", result = [], i, w, bits, resb, maxpower, power, c, data = {val:getNextValue(0), position:resetValue, index:1};
    function readBits(n){
      let bits=0, maxpower=Math.pow(2,n), power=1, resb;
      while(power!=maxpower){
        resb = data.val & data.position; data.position >>= 1;
        if (data.position==0){ data.position = resetValue; data.val = getNextValue(data.index++); }
        bits |= (resb>0 ? 1:0) * power; power <<= 1;
      }
      return bits;
    }
    let next = readBits(2);
    switch(next){
      case 0: c = f(readBits(8)); break;
      case 1: c = f(readBits(16)); break;
      case 2: return "";
    }
    dictionary[3]=c; w=c; result.push(c);
    while(true){
      if (data.index > length) return "";
      const cc = readBits(numBits);
      let code = cc;
      if (code===0){ dictionary[dictSize++] = f(readBits(8)); code = dictSize-1; enlargeIn--; }
      else if (code===1){ dictionary[dictSize++] = f(readBits(16)); code = dictSize-1; enlargeIn--; }
      else if (code===2){ return result.join(""); }
      if (enlargeIn===0){ enlargeIn=Math.pow(2, numBits); numBits++; }
      if (dictionary[code]) entry = dictionary[code];
      else if (code===dictSize) entry = w + w.charAt(0);
      else return null;
      result.push(entry); dictionary[dictSize++] = w + entry.charAt(0); w = entry; enlargeIn--; if (enlargeIn===0){enlargeIn=Math.pow(2, numBits); numBits++;}
    }
  }
  return {compressToBase64, decompressFromBase64};
})();

/* ----------------------------
  WebCrypto AES-GCM（パスワード→鍵導出はPBKDF2）
-----------------------------*/
async function deriveKeyFromPassword(password, salt){
  const enc = new TextEncoder();
  const keyMaterial = await crypto.subtle.importKey("raw", enc.encode(password), {name:"PBKDF2"}, false, ["deriveKey"]);
  return crypto.subtle.deriveKey(
    {name:"PBKDF2", salt, iterations:120000, hash:"SHA-256"},
    keyMaterial,
    {name:"AES-GCM", length:256},
    false,
    ["encrypt","decrypt"]
  );
}
async function encrypt(text, password){
  const enc = new TextEncoder();
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const key = await deriveKeyFromPassword(password, salt);
  const ct = await crypto.subtle.encrypt({name:"AES-GCM", iv}, key, enc.encode(text));
  return {iv: btoa(String.fromCharCode(...iv)), salt: btoa(String.fromCharCode(...salt)), data: btoa(String.fromCharCode(...new Uint8Array(ct)))};
}
async function decrypt(encPkg, password){
  const dec = new TextDecoder();
  const iv = Uint8Array.from(atob(encPkg.iv), c=>c.charCodeAt(0));
  const salt = Uint8Array.from(atob(encPkg.salt), c=>c.charCodeAt(0));
  const data = Uint8Array.from(atob(encPkg.data), c=>c.charCodeAt(0));
  const key = await deriveKeyFromPassword(password, salt);
  const pt = await crypto.subtle.decrypt({name:"AES-GCM", iv}, key, data);
  return dec.decode(pt);
}

/* ----------------------------
  データ構造とURL化
-----------------------------*/
function packAndEncode(obj){
  const json = JSON.stringify(obj);
  const b64 = LZ64.compressToBase64(json);
  return b64;
}
function decodeAndUnpack(b64){
  const json = LZ64.decompressFromBase64(b64);
  if (!json) throw new Error("データが壊れている可能性があります。");
  return JSON.parse(json);
}

function buildShareUrl(payload){
  const base = location.origin + location.pathname;
  // versioned hash: #v1:BASE64
  return base + "#v1:" + payload;
}

/* ----------------------------
  UI ロジック
-----------------------------*/
const el = id => document.getElementById(id);
const $create = el('create');
const $view = el('view');

function showCreate(){ $create.classList.remove('hidden'); $view.classList.add('hidden'); }
function showView(){ $view.classList.remove('hidden'); $create.classList.add('hidden'); }

function bytesLength(str){
  return new TextEncoder().encode(str).length;
}

async function makeUrl(){
  const title = el('title').value.trim();
  const body = el('body').value.trim();
  const unlockAt = el('unlockAt').value ? new Date(el('unlockAt').value).toISOString() : null;
  const pw = el('password').value;
  if (!title || !body){ alert('タイトルと本文を入力してください'); return; }

  const raw = {t:title, b:body, u:unlockAt, c:Date.now()};
  let wrapped;
  if (pw){
    const encPkg = await encrypt(JSON.stringify(raw), pw);
    wrapped = {e:true, ...encPkg};
  } else {
    wrapped = {e:false, d:raw};
  }
  const payload = packAndEncode(wrapped);
  const url = buildShareUrl(payload);
  el('shareUrl').value = url;
  el('result').classList.remove('hidden');
  el('urlSize').textContent = `URL長: ${url.length} 文字 / データ: 約 ${Math.ceil(bytesLength(payload)/1024)} KB`;
}

async function tryRender(hash){
  // 形式: #v1:<b64>
  const idx = hash.indexOf(':');
  const version = hash.slice(1, idx);
  const dataB64 = hash.slice(idx+1);
  if (version !== 'v1') throw new Error('未知のバージョン');
  const wrapped = decodeAndUnpack(dataB64);

  const gate = document.getElementById('gate');
  const pwWrap = document.getElementById('pwWrap');
  const lockinfo = document.getElementById('lockinfo');
  const vtitle = document.getElementById('vtitle');

  let raw;
  if (wrapped.e){
    gate.classList.remove('hidden');
    pwWrap.classList.remove('hidden');
    vtitle.textContent = '🔒 パスワードが必要です';
    lockinfo.textContent = '送信者から聞いたパスワードを入力してください。';
    document.getElementById('open').onclick = async ()=>{
      const pw = document.getElementById('viewPw').value;
      if (!pw) return alert('パスワードを入力してください');
      try{
        const json = await decrypt({iv:wrapped.iv, salt:wrapped.salt, data:wrapped.data}, pw);
        raw = JSON.parse(json);
        renderLetter(raw);
      }catch(e){ alert('パスワードが違うか、データが壊れています'); }
    };
  } else {
    raw = wrapped.d;
    renderLetter(raw);
  }
}

function renderLetter(raw){
  const {t, b, u} = raw;
  const gate = document.getElementById('gate');
  const letter = document.getElementById('letter');
  const ltitle = document.getElementById('ltitle');
  const lbody = document.getElementById('lbody');

  // 時間制限
  if (u){
    const now = Date.now();
    const unlockTs = Date.parse(u);
    if (now < unlockTs){
      showView();
      gate.classList.remove('hidden');
      document.getElementById('vtitle').textContent = '⏳ まだ開封できません';
      const d = new Date(unlockTs);
      const j = new Intl.DateTimeFormat('ja-JP', {dateStyle:'full', timeStyle:'short'}).format(d);
      document.getElementById('lockinfo').textContent = `開封可能: ${j}`;
      return;
    }
  }

  // 表示
  ltitle.textContent = t;
  lbody.textContent = b;
  showView();
  gate.classList.add('hidden');
  letter.classList.remove('hidden');
}

// イベント
el('make').addEventListener('click', makeUrl);

el('copy').addEventListener('click', async ()=>{
  try{
    await navigator.clipboard.writeText(el('shareUrl').value);
    const btn = document.getElementById('copy');
    const old = btn.textContent; btn.textContent = 'コピー済み✔️';
    setTimeout(()=>btn.textContent = old, 1200);
  }catch{ alert('コピーできませんでした'); }
});

document.getElementById('demo').addEventListener('click', ()=>{
  el('title').value = '落ち込んだときに開けて';
  el('body').value = 'いつも頑張ってるね。今日は深呼吸して、好きな音楽を1曲だけ聴いてみて。\n大丈夫、ちゃんと前に進んでるよ。';
});

document.getElementById('makeNew').addEventListener('click', ()=>{ location.hash = ''; location.reload(); });

// 起動時：#があれば閲覧モード
(function init(){
  if (location.hash && location.hash.startsWith('#v1:')){
    showView();
    tryRender(location.hash).catch(e=>{ alert('読み込みに失敗しました: '+e.message); showCreate(); });
  } else {
    showCreate();
  }
})();
</script>
</body>
</html>
